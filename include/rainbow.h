#ifndef __RAINBOW__
#define __RAINBOW__

#include <stdint.h>
#include <assert.h>
#include <stddef.h>

typedef int bool;
#define true	1
#define false	0

#ifdef RAINBOW_COMPACT

#define RB_NODE(_type)							\
struct									\
{									\
  _type *	lnode;							\
  _type *	rnode_red;						\
}

#else

#define RB_NODE(_type)							\
struct									\
{									\
  _type *	lnode;							\
  _type *	rnode;							\
  bool		is_red;							\
}

#endif

#define RB_TREE(_type)							\
struct									\
{									\
  _type *	root;							\
  _type *	null;							\
}

#define RB_GET_LEFT(_type, _field, _node)				\
  ((_node)->_field.lnode)
#define RB_SET_LEFT(_type, _field, _node, _left)			\
  do { (_node)->_field.lnode = _left; }					\
  while (0)

#ifndef RAINBOW_PARANOIA
#undef		assert
#define		assert(e) ((void) 0)

/* XXX: It's ugly and imply that rainbow.h is last include */

#endif

#ifdef RAINBOW_COMPACT

/* TODO: replace ssize_t (it's not included in the standard) */

/* ((ssize_t) -2)) = 11111110
 * ((size_t) 1)    = 00000001
 *
 * The red flag is located in the last bit of the pointer. */

#define RB_GET_RIGHT(_type, _field, _node)				\
  ((_type *) (((intptr_t) (_node)->_field.rnode_red) & ((ssize_t) -2)))
#define RB_SET_RIGHT(_type, _field, _node, _right)			\
  do { (_node)->_field.rnode_red = (_type *) (((uintptr_t) _right)	\
	| (((uintptr_t) (_node)->_field.rnode_red)			\
	& ((size_t) 1))); }						\
  while (0)
#define RB_GET_COLOR(_type, _field, _node)				\
  ((bool) (((uintptr_t) (_node)->_field.rnode_red) & ((size_t) 1)))
#define RB_SET_COLOR(_type, _field, _node, _red)			\
  do { (_node)->_field.rnode_red = (_type *)				\
	((((intptr_t) (_node)->_field.rnode_red) & ((ssize_t) -2))	\
	| ((ssize_t) _red)); }						\
  while (0)

#define RB_TO_RED(_type, _field, _node)					\
  do { (_node)->_field.rnode_red = (_type *)				\
	(((intptr_t) (_node)->_field.rnode_red)				\
	| ((size_t) 1)); }						\
  while (0)
#define RB_TO_BLACK(_type, _field, _node)				\
  do { (_node)->_field.rnode_red = (_type *)				\
	(((intptr_t) (_node)->_field.rnode_red)				\
	& ((ssize_t) -2)); }						\
  while (0)

#else

#define RB_GET_RIGHT(_type, _field, _node)				\
  ((_node)->_field.rnode)
#define RB_SET_RIGHT(_type, _field, _node, _right)			\
  do { (_node)->_field.rnode = _right; }				\
  while (0)
#define RB_GET_COLOR(_type, _field, _node)				\
  ((_node)->_field.is_red)
#define RB_SET_COLOR(_type, _field, _node, _red)			\
  do { (_node)->_field.is_red = (_red); }				\
  while (0)
#define RB_TO_RED(_type, _field, _node)					\
  do { (_node)->_field.is_red = true; }					\
  while (0)
#define RB_TO_BLACK(_type, _field, _node)				\
  do { (_node)->_field.is_red = false; }				\
  while (0)

#endif

#define RB_NODE_NEW(_type, _field, _tree, _node)			\
  do {									\
    RB_SET_LEFT(_type, _field, _node, (_tree)->null);			\
    RB_SET_RIGHT(_type, _field, _node, (_tree)->null);			\
    RB_TO_RED(_type, _field, (_node));					\
  } while (0)

/* A root is already black. */

#define RB_TREE_NEW(_type, _field, _tree, _null)			\
  do {									\
    (_tree)->root = _null;						\
    (_tree)->null = _null;						\
    RB_NODE_NEW(_type, _field, _tree, _null);				\
    RB_TO_BLACK(_type, _field, _null);					\
  } while (0)

/* Accessor to the deepest left branch. */

#define RB_FIRST(_type, _field, _tree, _root, _ref)			\
  do {									\
    (_ref) = (_root);							\
									\
    if ((_ref) != (_tree)->null)					\
      for (; RB_GET_LEFT(_type, _field, (_ref)) != (_tree)->null;	\
	   (_ref) = RB_GET_LEFT(_type, _field, (_ref)));		\
  } while (0)

/* Accessor to the deepest right branch. */

#define RB_LAST(_type, _field, _tree, _root, _ref)			\
  do {									\
    (_ref) = (_root);							\
									\
    if ((_ref) != (_tree)->null)					\
      for (; RB_GET_RIGHT(_type, _field, (_ref)) != (_tree)->null;	\
	   (_ref) = RB_GET_RIGHT(_type, _field, (_ref)));		\
  } while (0)

/*
 *   P            Q
 *  / \          / \
 * A   Q   =>   P   C
 *    / \      / \
 *   B   C    A   B
 */

#define RB_ROTATE_LEFT(_type, _field, _node, _ref)			\
  do {									\
    _ref = RB_GET_RIGHT(_type, _field, _node);				\
									\
    RB_SET_RIGHT(_type, _field, (_node),				\
	RB_GET_LEFT(_type, _field, _ref));				\
    RB_SET_LEFT(_type, _field, _ref, _node);				\
  } while (0)

/*
 *   P            Q
 *  / \          / \
 * A   Q   <=   P   C
 *    / \      / \
 *   B   C    A   B
 */

#define RB_ROTATE_RIGHT(_type, _field, _node, _ref)			\
  do {									\
    _ref = RB_GET_LEFT(_type, _field, _node);				\
									\
    RB_SET_LEFT(_type, _field, _node,					\
	RB_GET_RIGHT(_type, _field, _ref));				\
    RB_SET_RIGHT(_type, _field, _ref, _node);				\
  } while (0)

/*
 * Macro to generates function prototypes that correspond to the
 * functions generated by an equivalently parameterized
 * call to RB_GENERATE.
 */

#define RB_PROTOTYPE(_attr, _prefix, _tree_type, _type)			\
									\
_attr void								\
_prefix##new_tree(_tree_type *tree);					\
									\
_attr void								\
_prefix##new_node(_tree_type *tree, _type *node);			\
									\
_attr bool								\
_prefix##color(_type *node);						\
									\
_attr _type *								\
_prefix##first(_tree_type *tree);					\
									\
_attr _type *								\
_prefix##last(_tree_type *tree);					\
									\
_attr _type *								\
_prefix##next(_tree_type *tree, _type *node);				\
									\
_attr _type *								\
_prefix##prev(_tree_type *tree, _type *node);				\
									\
_attr _type *								\
_prefix##left(_tree_type *tree, _type *node);				\
									\
_attr _type *								\
_prefix##right(_tree_type *tree, _type *node);				\
									\
_attr _type *								\
_prefix##search(_tree_type *tree, _type *key);				\
									\
_attr _type *								\
_prefix##n_search(_tree_type *tree, _type *key);			\
									\
_attr _type *								\
_prefix##p_search(_tree_type *tree, _type *key);			\
									\
_attr void								\
_prefix##insert(_tree_type *tree, _type *node);				\
									\
_attr void								\
_prefix##remove(_tree_type *tree, _type **ref, bool is_real_node);	\
									\
_attr void								\
_prefix##iter(_tree_type *tree,						\
    void (*func)(_type *, _type *, void *),				\
    void * data);							\

/*
 * Macro generates a type-specific red-black tree implementation,
 * based on the above macros.
 *
 * Arguments:
 *
 *  _attr      : function attribute for generated functions
 *               (ex: static)
 *  _prefix    : prefix for generated functions (ex: example_)
 *  _tree_type : type for red-black tree data structure
 *               (ex: example_t)
 *  _type      : type for redÃ¨black tree node data structure
 *               (ex: example_node_t)
 *  _field     : name of red-black tree node linkage (ex: link)
 *  _compare   : node comparison function name, with the
 *               following prototype:
 *                  int (_compare *)(_type *_node, _type *_other);
 *                                          ^^^^^
 *                                       or _key
 *                  Interpretation of comparison function
 *                  return values:
 *                    -1 : _node < _other
 *                     0 : _node = _other
 *                     1 : _node > _other
 *                  In all cases, the _node or _key macro argument is
 *                  the first argument to the comparison function,
 *                  which makes it possible to write comparison
 *                  functions that treat the first argument specially.
 */

#line 268 "rainbow.h"

/*                                                   limit of the space... */
#define RB_GENERATE(_attr, _prefix, _tree_type, _type, _field)		\
									\
typedef int (*_prefix##compare)(_type *, _type *);			\
									\
struct _prefix##stack {							\
  int		cmp;							\
  _type *	node;							\
};									\
									\
static _type _prefix##null;						\
									\
_attr void								\
_prefix##new_tree(_tree_type *tree)					\
{									\
  _type *	tmp = &_prefix##null;					\
									\
  RB_TREE_NEW(_type, _field, tree, tmp);				\
}									\
									\
_attr void								\
_prefix##new_node(_tree_type *tree, _type *node)			\
{									\
  RB_NODE_NEW(_type, _field, tree, node);				\
}									\
									\
_attr bool								\
_prefix##color(_type *node)						\
{									\
  return (RB_GET_COLOR(_type, _field, node));				\
}									\
									\
_attr _type *								\
_prefix##first(_tree_type *tree)					\
{									\
  _type *	ret;							\
									\
  RB_FIRST(_type, _field, tree, tree->root, ret);			\
									\
  if (ret == tree->null)						\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
_attr _type *								\
_prefix##last(_tree_type *tree)						\
{									\
  _type *	ret;							\
									\
  RB_LAST(_type, _field, tree, tree->root, ret);			\
									\
  if (ret == tree->null)						\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
_attr _type *								\
_prefix##next(_tree_type *tree, _type *node, _prefix##compare _cmp)	\
{									\
  _type *	ret;							\
									\
  if (RB_GET_RIGHT(_type,_field, node) != tree->null)			\
    RB_FIRST(_type, _field, tree,					\
      RB_GET_RIGHT(_type, _field, node), ret);				\
  else									\
    {									\
      _type *	tmp = tree->root;					\
									\
      assert(tmp != tree->null);					\
      /* Or undefined behavior. */					\
									\
      ret = tree->null;							\
									\
      while (true)							\
	{								\
	  int cmp = (*_cmp)(node, tmp);					\
									\
	  if (cmp < 0)							\
	    {								\
	      ret = tmp;						\
	      tmp = RB_GET_LEFT(_type, _field, tmp);			\
	    }								\
	  else if (cmp > 0)						\
	    tmp = RB_GET_RIGHT(_type, _field, tmp);			\
	  else								\
	    break;							\
									\
	  assert(tmp != tree->null);					\
	  /* Or undefined behavior. */					\
	}								\
    }									\
									\
  if (ret == tree->null)						\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
_attr _type *								\
_prefix##prev(_tree_type *tree, _type *node, _prefix##compare _cmp)	\
{									\
  _type *	ret;							\
									\
  if (RB_GET_LEFT(_type,_field, node) != tree->null)			\
    RB_LAST(_type, _field, tree,					\
      RB_GET_LEFT(_type, _field, node), ret);				\
  else									\
    {									\
      _type *	tmp = tree->root;					\
									\
      assert(tmp != tree->null);					\
      /* Or undefined behavior. */					\
									\
      ret = tree->null;							\
									\
      while (true)							\
	{								\
	  int cmp = (*_cmp)(node, tmp);					\
									\
	  if (cmp < 0)							\
	    {								\
	      ret = tmp;						\
	      tmp = RB_GET_LEFT(_type, _field, tmp);			\
	    }								\
	  else if (cmp > 0)						\
	    tmp = RB_GET_RIGHT(_type, _field, tmp);			\
	  else								\
	    break;							\
									\
	  assert(tmp != tree->null);					\
	  /* Or undefined behavior. */					\
	}								\
    }									\
									\
  if (ret == tree->null)						\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
void									\
_prefix##set_left(_tree_type *tree, _type **node, _type *replace)	\
{									\
  if (replace == NULL)							\
    RB_SET_LEFT(_type, _field, (*node), tree->null);			\
  else									\
    RB_SET_LEFT(_type, _field, (*node), replace);			\
}									\
									\
void									\
_prefix##set_right(_tree_type *tree, _type **node, _type *replace)	\
{									\
  if (replace == NULL)							\
    RB_SET_RIGHT(_type, _field, (*node), tree->null);			\
  else									\
    RB_SET_RIGHT(_type, _field, (*node), replace);			\
}									\
									\
_attr _type *								\
_prefix##left(_tree_type *tree, _type *node)				\
{									\
  _type *	ret;							\
									\
  if (node == tree->null						\
      || (ret = RB_GET_LEFT(_type, _field, node)) == tree->null)	\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
_attr _type *								\
_prefix##right(_tree_type *tree, _type *node)				\
{									\
  _type *	ret;							\
									\
  if (node == tree->null						\
      || (ret = RB_GET_RIGHT(_type, _field, node)) == tree->null)	\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
_attr _type *								\
_prefix##search(_tree_type *tree, _type *key, _prefix##compare _cmp)	\
{									\
  _type *	ret;							\
  int		cmp;							\
									\
  ret = tree->root;							\
									\
  while (ret != tree->null						\
	 && (cmp = (*_cmp)(key, ret)) != 0)				\
    {									\
      if (cmp < 0)							\
	ret = RB_GET_LEFT(_type, _field, ret);				\
      else								\
	ret = RB_GET_RIGHT(_type, _field, ret);				\
    }									\
									\
  if (ret == tree->null)						\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
_attr _type *								\
_prefix##n_search(_tree_type *tree, _type *key, _prefix##compare _cmp)	\
{									\
  _type *	ret;							\
  _type *	tmp;							\
									\
  ret = tree->null;							\
									\
  while (tmp != tree->null)						\
    {									\
      int cmp = (*_cmp)(key, tmp);					\
									\
      if (cmp < 0)							\
	{								\
	  ret = tmp;							\
	  tmp = RB_GET_LEFT(_type, _field, tmp);			\
	}								\
      else if (cmp > 0)							\
	tmp = RB_GET_RIGHT(_type, _field, tmp);				\
      else								\
	{								\
	  ret = tmp;							\
	  break;							\
	}								\
    }									\
									\
  if (ret == tree->null)						\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
_attr _type *								\
_prefix##p_search(_tree_type *tree, _type *key, _prefix##compare _cmp)	\
{									\
  _type *	ret;							\
  _type *	tmp;							\
									\
  ret = tree->null;							\
									\
  while (tmp != tree->null)						\
    {									\
      int cmp = (*_cmp)(key, tmp);					\
									\
      if (cmp < 0)							\
	tmp = RB_GET_LEFT(_type, _field, tmp);				\
      else if (cmp > 0)							\
	{								\
	  ret = tmp;							\
	  tmp = RB_GET_RIGHT(_type, _field, tmp);			\
	}								\
      else								\
	{								\
	  ret = tmp;							\
	  break;							\
	}								\
    }									\
									\
  if (ret == tree->null)						\
    ret = NULL;								\
									\
  return (ret);								\
}									\
									\
_attr void								\
_prefix##insert_with_specific_path(_tree_type *tree, _type *node,	\
    int (*_cmp)(_type *, _type *),					\
    struct _prefix##stack path[sizeof(void *) << 4],			\
    struct _prefix##stack * ptr)					\
{									\
  /* Balancing the tree */						\
									\
  for (ptr--; (uintptr_t) ptr >= (uintptr_t) path; ptr--)		\
    {									\
      _type * current = ptr->node;					\
									\
      if (ptr->cmp < 0)							\
	{								\
	  _type * l = ptr[1].node;					\
									\
	  RB_SET_LEFT(_type, _field, current, l);			\
									\
	  if (RB_GET_COLOR(_type, _field, l))				\
	    {								\
	      _type * ll = RB_GET_LEFT(_type, _field, l);		\
									\
	      if (RB_GET_COLOR(_type, _field, ll))			\
		{							\
		  _type * tmp;						\
									\
		  RB_TO_BLACK(_type, _field, ll);			\
		  RB_ROTATE_RIGHT(_type, _field, current, tmp);		\
									\
		  current = tmp;					\
		}							\
	    }								\
	  else								\
	    return;							\
	}								\
      else								\
	{								\
	  _type * r = ptr[1].node;					\
									\
	  RB_SET_RIGHT(_type, _field, current, r);			\
									\
	  if (RB_GET_COLOR(_type, _field, r))				\
	    {								\
	      _type * l = RB_GET_LEFT(_type, _field, current);		\
									\
	      if (RB_GET_COLOR(_type, _field, l))			\
		{							\
		  RB_TO_BLACK(_type, _field, l);			\
		  RB_TO_BLACK(_type, _field, r);			\
		  RB_TO_RED(_type, _field, current);			\
		}							\
	      else							\
		{							\
		  _type * tmp;						\
		  bool is_red = RB_GET_COLOR(_type, _field, current);	\
									\
		  RB_ROTATE_LEFT(_type, _field, current, tmp);		\
		  RB_SET_COLOR(_type, _field, tmp, is_red);		\
		  RB_TO_RED(_type, _field, current);			\
									\
		  current = tmp;					\
		}							\
	    }								\
	  else								\
	    return;							\
	}								\
									\
      ptr->node = current;						\
    }									\
									\
  /* The balancing imply the wholes tree. */				\
  tree->root = path->node;						\
  RB_TO_BLACK(_type, _field, tree->root);				\
}									\
									\
_attr void								\
_prefix##insert(_tree_type *tree, _type *node,				\
    int (*_cmp)(_type *, _type *))					\
{									\
  struct _prefix##stack	  path[sizeof(void *) << 4];			\
  struct _prefix##stack * ptr;						\
									\
  /* This array retraces the path where place the node accorgind to	\
   * the compare function. The array is limited to 128 on a modern	\
   * computer which leaves the possibility to manipulate a tree		\
   * containing 2^128 datas maximum.					\
   *									\
   * This allows to avoid recursion and simulate the stack.		\
   */									\
									\
  RB_NODE_NEW(_type, _field, tree, node);				\
									\
  path->node = tree->root;						\
									\
  for (ptr = path; ptr->node != tree->null; ptr++)			\
    {									\
      int cmp = ptr->cmp = (*_cmp)(node, ptr->node);			\
									\
      assert(cmp != 0);							\
      /* Or node already exists. */					\
									\
      if (cmp < 0)							\
	ptr[1].node = RB_GET_LEFT(_type, _field, ptr->node);		\
      else								\
	ptr[1].node = RB_GET_RIGHT(_type, _field, ptr->node);		\
    }									\
									\
  ptr->node = node;							\
									\
  _prefix##insert_with_specific_path(tree, node, _cmp, path, ptr);	\
}									\
									\
_attr void								\
_prefix##remove(_tree_type *tree, _type **ref, bool is_real_node,	\
    _prefix##compare _cmp)						\
{									\
  _type *	node;							\
									\
  struct {								\
    _type *	node;							\
    int		cmp;							\
  } path[sizeof(void *) << 4], *path_ptr, *node_ptr;			\
									\
  node_ptr = NULL;							\
  path->node = tree->root;						\
									\
  for (path_ptr = path; path_ptr->node != tree->null; path_ptr++)	\
    {									\
      int cmp = path_ptr->cmp = (*_cmp)((*ref), path_ptr->node);	\
									\
      if (cmp < 0)							\
	path_ptr[1].node = RB_GET_LEFT(_type, _field, path_ptr->node);	\
      else								\
	{								\
	  path_ptr[1].node =						\
	    RB_GET_RIGHT(_type, _field, path_ptr->node);		\
									\
	  if (cmp == 0)							\
	    {								\
	      /* Find node's successor, in preparation for swap. */	\
									\
	      path_ptr->cmp = 1;					\
	      node_ptr = path_ptr;					\
									\
	      for (path_ptr++; path_ptr->node != tree->null;		\
		   path_ptr++)						\
		{							\
		  path_ptr->cmp = -1;					\
		  path_ptr[1].node =					\
		    RB_GET_LEFT(_type, _field, path_ptr->node);		\
		}							\
									\
	      break;							\
	    }								\
	}								\
    }									\
  if (node_ptr == NULL && is_real_node == false)			\
    {									\
      (*ref) = NULL;							\
									\
      return; /* Node does not exist. */				\
    }									\
  if (is_real_node)							\
    {									\
      node = (*ref);							\
									\
      assert(node_ptr->node == node);					\
      /* Or remove a bad node. */					\
    }									\
  else									\
    {									\
      node = node_ptr->node;						\
      (*ref) = node;							\
    }									\
									\
  path_ptr--;								\
									\
  if (path_ptr->node != node)						\
    {									\
      bool is_red = RB_GET_COLOR(_type, _field, path_ptr->node);	\
									\
      RB_SET_COLOR(_type, _field, path_ptr->node,			\
	RB_GET_COLOR(_type, _field, node));				\
      RB_SET_LEFT(_type, _field, path_ptr->node,			\
	RB_GET_LEFT(_type, _field, node));				\
      /* If node's successor is its right child, the following code	\
       * will do the wrong thing for the right child pointer.		\
       * However, it doesn't matter, because the pointer will be	\
       * properly set when the sucessor is pruned.			\
       */								\
      RB_SET_RIGHT(_type, _field, path_ptr->node,			\
	RB_GET_RIGHT(_type, _field, node));				\
      RB_SET_COLOR(_type, _field, node, is_red);			\
      /* The pruned leaf node's child pointers are never accessed	\
       * again, so don't bother setting them to null.			\
       */								\
      node_ptr->node = path_ptr->node;					\
      path_ptr->node = node;						\
									\
      if (node_ptr == path)						\
	tree->root = node_ptr->node;					\
      else								\
	{								\
	  if (node_ptr[-1].cmp < 0)					\
	    RB_SET_LEFT(_type, _field, node_ptr[-1].node,		\
	      node_ptr->node);						\
	  else								\
	    RB_SET_RIGHT(_type, _field, node_ptr[-1].node,		\
	      node_ptr->node);						\
	}								\
    }									\
  else									\
    {									\
      /* In this case, the node has no right child (no successor). */	\
									\
      _type * l = RB_GET_LEFT(_type, _field, node);			\
									\
      if (l != tree->null)						\
	{								\
	  /* Node has no successor, but it has a left child.		\
	   * Splice node out, without losing the left child.		\
	   *								\
	   * ?     ?          ?      ?					\
	   *  \     \        /      /					\
	   *   A =>  B or   A   => B					\
	   *  /            /						\
	   * B            B						\
	   *								\
	   * with A[black] and B[red] to B[black]			\
	   */								\
									\
	  assert(RB_GET_COLOR(_type, _field, node) == false);		\
	  assert(RB_GET_COLOR(_type, _field, l));			\
	  /* Parent of red node is black. */				\
									\
	  RB_TO_BLACK(_type, _field, l);				\
									\
	  if (path_ptr == path)						\
	    tree->root = l;						\
	  else								\
	    {								\
	      if (path_ptr[-1].cmp < 0)					\
		RB_SET_LEFT(_type, _field, path_ptr[-1].node, l);	\
	      else							\
		RB_SET_RIGHT(_type, _field, path_ptr[-1].node, l);	\
	    }								\
									\
	  return;							\
	}								\
      else if (path_ptr == path)					\
	{								\
	  tree->root = tree->null;					\
	  return;							\
	}								\
    }									\
  if (RB_GET_COLOR(_type, _field, path_ptr->node))			\
    {									\
      /* Prune red node, wich requires no fixup. */			\
      assert(path_ptr[-1].cmp < 0);					\
									\
      RB_SET_LEFT(_type, _field, path_ptr[-1].node, tree->null);	\
									\
      return;								\
    }									\
									\
  /* The node to be pruned is black, so unwind until balance is		\
   * restored.								\
   */									\
  path_ptr->node = tree->null;						\
  /* Party hard. */							\
									\
  for (path_ptr--; (uintptr_t)path_ptr >= (uintptr_t)path; path_ptr--)	\
    {									\
      assert(path_ptr->cmp != 0);					\
      /* Or not handle this case before. */				\
									\
      if (path_ptr->cmp < 0)						\
	{								\
	  RB_SET_LEFT(_type, _field, path_ptr->node,			\
	    path_ptr[1].node);						\
									\
	  assert(RB_GET_COLOR(_type, _field, path_ptr[1].node)		\
	    == false);							\
									\
	  if (RB_GET_COLOR(_type, _field, path_ptr->node))		\
	    {								\
	      _type * r = RB_GET_RIGHT(_type, _field,			\
		path_ptr->node);					\
	      _type * rl = RB_GET_LEFT(_type, _field, r);		\
	      _type * tmp;						\
									\
	      if (RB_GET_COLOR(_type, _field, rl))			\
		{							\
		  RB_TO_BLACK(_type, _field, path_ptr->node);		\
		  RB_ROTATE_RIGHT(_type, _field, r, tmp);		\
		  RB_SET_RIGHT(_type, _field, path_ptr->node, tmp);	\
		  RB_ROTATE_LEFT(_type, _field, path_ptr->node, tmp);	\
		}							\
	      else							\
		RB_ROTATE_LEFT(_type, _field, path_ptr->node, tmp);	\
									\
	      /* Balance restored, but rotation modified		\
	       * subtree root.						\
	       */							\
	      assert((uintptr_t) path_ptr > (uintptr_t) path);		\
	      /* Or path_ptr[-1] is wrong. */				\
									\
	      if (path_ptr[-1].cmp < 0)					\
		RB_SET_LEFT(_type, _field, path_ptr[-1].node, tmp);	\
	      else							\
		RB_SET_RIGHT(_type, _field, path_ptr[-1].node, tmp);	\
									\
	      return;							\
	    }								\
	  else								\
	    {								\
	      _type * r = RB_GET_RIGHT(_type, _field, path_ptr->node);	\
	      _type * rl = RB_GET_LEFT(_type, _field, r);		\
									\
	      if (RB_GET_COLOR(_type, _field, rl))			\
		{							\
		  _type * tmp;						\
									\
		  RB_TO_BLACK(_type, _field, rl);			\
		  RB_ROTATE_RIGHT(_type, _field, r, tmp);		\
		  RB_SET_RIGHT(_type, _field, path_ptr->node, tmp);	\
		  RB_ROTATE_LEFT(_type, _field, path_ptr->node, tmp);	\
									\
		  /* Balance restored, but rotation modified subtree	\
		   * root, wich may actually be the tree root.		\
		   */							\
									\
		  if (path_ptr == path)					\
		    tree->root = tmp;					\
		  else							\
		    {							\
		      if (path_ptr[-1].cmp < 0)				\
			RB_SET_LEFT(_type, _field,			\
			  path_ptr[-1].node, tmp);			\
		      else						\
			RB_SET_RIGHT(_type, _field,			\
			  path_ptr[-1].node, tmp);			\
		    }							\
									\
		  return;						\
		}							\
	      else							\
		{							\
		  _type * tmp;						\
									\
		  RB_TO_RED(_type, _field, path_ptr->node);		\
		  RB_ROTATE_LEFT(_type, _field, path_ptr->node, tmp);	\
									\
		  path_ptr->node = tmp;					\
		}							\
	    }								\
	}								\
      else								\
	{								\
	  _type * l;							\
									\
	  RB_SET_RIGHT(_type, _field, path_ptr->node,			\
	    path_ptr[1].node);						\
	  l = RB_GET_LEFT(_type, _field, path_ptr->node);		\
									\
	  if (RB_GET_COLOR(_type, _field, l))				\
	    {								\
	      _type * tmp;						\
	      _type * lr = RB_GET_RIGHT(_type, _field, l);		\
	      _type * lrl = RB_GET_LEFT(_type, _field, lr);		\
									\
	      if (RB_GET_COLOR(_type, _field, lrl))			\
		{							\
		  _type * ump;						\
									\
									\
		  /*     [node]       [ump]         [ump]		\
		   *      /  \         / \           / \		\
		   *  [ump]    D      A [node]      A [tmp]		\
		   *   / \        =>     /  \   =>     / \		\
		   *  A [tmp]         [tmp]  D        B [node]		\
		   *     / \           / \               /  \		\
		   *    B   C         B   C             C    D		\
		   *							\
		   *         [tmp]					\
		   *         /   \					\
		   *  =>  [ump] [node]					\
		   *       / \   /  \					\
		   *      A   B C    D					\
		   *							\
		   * with [tmp] to black				\
		   */							\
									\
		  RB_TO_BLACK(_type, _field, lrl);			\
		  RB_ROTATE_RIGHT(_type, _field, path_ptr->node, ump);	\
		  RB_ROTATE_RIGHT(_type, _field, path_ptr->node, tmp);	\
		  RB_SET_RIGHT(_type, _field, ump, tmp);		\
		  RB_ROTATE_LEFT(_type, _field, ump, tmp);		\
		}							\
	      else							\
		{							\
		  assert(lr != tree->null);				\
		  /* If lrl node is black, it is possible that		\
		   * lrl node == tree->null (tree->null is		\
		   * already black) and also lr node == tree->null.	\
		   *							\
		   * It is not possible in this case because we		\
		   * will change the color of this node to red and	\
		   * the tree->null must forever have			\
		   * the black color.					\
		   */							\
									\
		  RB_TO_RED(_type, _field, lr);				\
		  RB_ROTATE_RIGHT(_type, _field, path_ptr->node, tmp);	\
		  RB_TO_BLACK(_type, _field, tmp);			\
		}							\
									\
	      /* Balance restored, but rotation modified subtree root,	\
	       * wich may actually be the tree root.			\
	       */							\
									\
	      if (path_ptr == path)					\
		tree->root = tmp;					\
	      else							\
		{							\
		  if (path_ptr[-1].cmp < 0)				\
		    RB_SET_LEFT(_type, _field,				\
		      path_ptr[-1].node, tmp);				\
		  else							\
		    RB_SET_RIGHT(_type, _field,				\
		      path_ptr[-1].node, tmp);				\
		}							\
									\
	      return;							\
	    }								\
	  else if (RB_GET_COLOR(_type, _field, path_ptr->node))		\
	    {								\
	      _type * ll = RB_GET_LEFT(_type, _field, l);		\
									\
	      if (RB_GET_COLOR(_type, _field, ll))			\
		{							\
		  _type * tmp;						\
									\
		  RB_TO_BLACK(_type, _field, path_ptr->node);		\
		  RB_TO_RED(_type, _field, l);				\
		  RB_TO_BLACK(_type, _field, ll);			\
		  RB_ROTATE_RIGHT(_type, _field, path_ptr->node, tmp);	\
									\
		  /* Balance restored, but rotation modified		\
		   * subtree root.					\
		   */							\
		  assert((uintptr_t) path_ptr > (uintptr_t) path);	\
		  /* Or path_ptr[-1] is wrong. */			\
									\
		  if (path_ptr[-1].cmp < 0)				\
		    RB_SET_LEFT(_type, _field,				\
		      path_ptr[-1].node, tmp);				\
		  else							\
		    RB_SET_RIGHT(_type, _field,				\
		      path_ptr[-1].node, tmp);				\
									\
		  return;						\
		}							\
	      else							\
		{							\
		  RB_TO_RED(_type, _field, l); /* TODO: check this ! */	\
		  RB_TO_BLACK(_type, _field, path_ptr->node);		\
									\
		  /* Balance restored. */				\
		  return;						\
		}							\
	    }								\
	  else								\
	    {								\
	      _type * ll = RB_GET_LEFT(_type, _field, l);		\
									\
	      if (RB_GET_COLOR(_type, _field, ll))			\
		{							\
		  _type * tmp;						\
									\
		  RB_TO_BLACK(_type, _field, ll);			\
		  RB_ROTATE_RIGHT(_type, _field, path_ptr->node, tmp);	\
									\
		  /* Balance restored, but rotation modified subtree	\
		   * root, which may actually be the tree root.		\
		   */							\
									\
		  if (path_ptr == path)					\
		    tree->root = tmp;					\
		  else							\
		    {							\
		      if (path_ptr[-1].cmp < 0)				\
			RB_SET_LEFT(_type, _field,			\
			  path_ptr[-1].node, tmp);			\
		      else						\
			RB_SET_RIGHT(_type, _field,			\
			  path_ptr[-1].node, tmp);			\
		    }							\
									\
		  return;						\
		}							\
	      else							\
		RB_TO_RED(_type, _field, l); /* TODO: check this ! */	\
	    }								\
	}								\
    }									\
									\
  tree->root = path->node;						\
  assert(RB_GET_COLOR(_type, _field, tree->root) == false);		\
  /* Color of root must forever be black. */				\
}									\
									\
_attr long *								\
_prefix##iter(_tree_type *tree,						\
    long * (*func)(_type *, _type *, long *),				\
    long * data)							\
{									\
  _type *	stack[sizeof(void *) << 4];				\
  _type **	stack_ptr;						\
									\
  stack_ptr = stack;							\
									\
  if (tree->root != tree->null)						\
    {									\
      data = (*func)(NULL, tree->root, data);				\
      (*stack_ptr++) = tree->root;					\
    }									\
									\
  while ((uintptr_t)stack_ptr > (uintptr_t)stack)			\
    {									\
      _type * current = (*--stack_ptr);					\
      _type * tmp;							\
									\
      if ((tmp = RB_GET_LEFT(_type, _field, current)) != tree->null)	\
	{								\
	  data = (*func)(current, tmp, data);				\
	  (*stack_ptr++) = tmp;						\
	}								\
      if ((tmp = RB_GET_RIGHT(_type, _field, current)) != tree->null)	\
	{								\
	  data = (*func)(current, tmp, data);				\
	  (*stack_ptr++) = tmp;						\
	}								\
    }									\
									\
  return (data);							\
}									\

#endif
